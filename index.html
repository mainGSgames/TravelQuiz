<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backpacker AI Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
            touch-action: manipulation;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .ui-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Header UI */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 15px;
        }

        .team-info {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 200px;
            transition: all 0.3s ease;
        }

        .team-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .team-money {
            color: #4ade80;
            font-size: 1.1em;
        }

        .team-distance {
            color: #fbbf24;
            font-size: 0.9em;
            margin-top: 3px;
        }

        .team-location {
            color: #94a3b8;
            font-size: 0.8em;
            margin-top: 2px;
        }

        .turn-info {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
        }

        .turns-remaining {
            font-size: 0.9em;
            color: #fbbf24;
            margin-top: 5px;
        }

        /* Setup Screen */
        .setup-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .setup-content {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .setup-content h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #4ade80, #60a5fa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .team-setup {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
        }

        .team-setup input {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: white;
            font-size: 1em;
        }

        .team-setup input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .btn {
            background: linear-gradient(45deg, #4ade80, #22c55e);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Question UI ‚Äì placerad lite h√∂gre s√• mobilen inte sk√§r av sista knappen */
        .question-panel {
            position: absolute;
            left: 0;
            right: 0;

            /* üöÄ Viktigt: l√§gg ett avst√•nd till OS-navigationslisten */
            bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);

            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(20px);
            padding: 30px;

            /* Glid-animation in/ut */
            transform: translateY(100%);
            transition: transform 0.5s ease;

            /* H√∂jdbegr√§nsning ‚Äì 180 px reserverat f√∂r header + marginaler */
            max-height: calc(100dvh - 180px);
            overflow-y: auto;
            overscroll-behavior: contain;
        }


        .question-panel.active {
            transform: translateY(0);
        }

        .question-text {
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
        }

        .answers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .answer-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .answer-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: #60a5fa;
            transform: scale(1.02);
        }

        .answer-btn.correct {
            background: rgba(74, 222, 128, 0.3);
            border-color: #4ade80;
        }

        .answer-btn.incorrect {
            background: rgba(248, 113, 113, 0.3);
            border-color: #f87171;
        }

        /* Travel Options */
        .travel-options {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.5s ease;
            z-index: 5;
            max-width: 90%;
            width: 900px;
            max-height: 90%;
            overflow-y: auto;
        }

        .travel-options.active {
            transform: translate(-50%, -50%) scale(1);
        }

        .travel-options h2 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .local-job-option {
            background: linear-gradient(45deg, #3b82f6, #2563eb);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .local-job-option:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .tickets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .ticket{
            /* ‚ÄÜIkon v√§nster, info h√∂ger  */
            display:grid;
            grid-template-columns:auto 1fr;     /* [ikon] [text-kolumn] */
            grid-template-rows:repeat(4,auto);  /* destination, f√§rdmedel, distans, pris */
            gap:4px 14px;                       /* lite luft mellan ikon & text */
            align-items:center;
            padding:15px 18px;                  /* l√§gre padding = l√§gre h√∂jd */
        }

        .ticket:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .ticket.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .ticket-icon{
            grid-row:1 / -1;                    /* l√•t ikonen sp√§nna alla rader */
            font-size:2.2em;                    /* lagom stor men inte y-slukande */
            margin:0;                           /* slopa bottenmarginalen */
        }

        .ticket-destination{
            font-size:1.1em;
            font-weight:600;
        }

        .ticket-distance {
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .ticket-cost {
            color: #4ade80;
            font-size: 1.1em;
            margin:0;
        }

        /* Location Info */
        .location-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            text-align: center;
            pointer-events: none;
        }

        .location-name {
            font-size: 1.3em;
            font-weight: bold;
        }

        /* Game Over Screen */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .game-over.active {
            display: flex;
        }

        .game-over-content {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            width: 90%;
        }

        .game-over h1 {
            font-size: 3em;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #fbbf24, #f59e0b);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .final-scores {
            margin: 30px 0;
        }

        .score-item {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .winner {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid #4ade80;
        }

        .ticket.visited      { border: 2px dashed #f59e0b; }
        .ticket .visited-tag { color:#fbbf24;font-size:.85em;margin-top:4px; }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header {
                padding: 10px;
            }
            
            .team-info, .turn-info {
                padding: 10px 15px;
                min-width: auto;
            }
            
            .question-panel {
                padding: 20px;
            }
            
            .answers-grid {
                grid-template-columns: 1fr;
            }
            
            .tickets-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .header {
                padding: 5px 20px;
            }
            
            .question-panel {
                padding: 15px;
            }
            
            .question-text {
                font-size: 1.1em;
                margin-bottom: 10px;
            }
            
            .answer-btn {
                padding: 10px;
            }
        }
		
		:root { --reply-gap: 56px; }          /* defaultlandskap */
		@media (orientation: portrait) { :root { --reply-gap: 12px; } } /* portr√§tt */

		.question-panel {
		  bottom: calc(env(safe-area-inset-bottom, 0px) + var(--reply-gap));
		}
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        
        <div class="ui-overlay">
            <!-- Header UI -->
            <div class="header" id="header" style="display: none;">
                <div id="teamInfoContainer"></div>
                <div class="turn-info">
                    <div>Turn <span id="currentTurn">1</span> / <span id="maxTurns">20</span></div>
                    <div class="turns-remaining">Turns left: <span id="turnsLeft">19</span></div>
                </div>
            </div>

            <!-- Location Info -->
            <div class="location-info" id="locationInfo" style="display: none;">
                <div class="location-name" id="locationName"></div>
            </div>

            <!-- Question Panel -->
            <div class="question-panel" id="questionPanel">
                <div class="question-text" id="questionText"></div>
                <div class="answers-grid" id="answersGrid"></div>
                <div style="text-align: center; color: #94a3b8; font-size: 0.9em;">
                    Time remaining: <span id="timer">30</span>s
                </div>
            </div>

            <!-- Travel Options -->
            <div class="travel-options" id="travelOptions">
                <h2>Choose Your Next Move</h2>
                <div class="local-job-option" onclick="takeLocalJob()">
                    <div style="font-size: 2em;">üíº</div>
                    <div style="font-size: 1.2em; font-weight: bold;">Take a Local Job</div>
                    <div style="color: #94a3b8;">Answer a harder question to earn extra money</div>
                    <div style="color: #4ade80; margin-top: 10px;">Potential earnings: $200-800</div>
                </div>
                <div class="tickets-grid" id="ticketsGrid"></div>
            </div>
        </div>

        <!-- Setup Screen -->
        <div class="setup-screen" id="setupScreen">
            <div class="setup-content">
                <h1>üåç Backpacker Quiz</h1>
                <div id="teamSetupContainer">
                    <div class="team-setup">
                        <label>Team 1 Name:</label>
                        <input type="text" id="team1Name" placeholder="Enter team name" value="Team 1">
                    </div>
                    <div class="team-setup">
                        <label>Team 2 Name:</label>
                        <input type="text" id="team2Name" placeholder="Enter team name" value="Team 2">
                    </div>
                </div>
                <label>Number of Teams:</label>
                <select id="teamCount" style="width: 100%; padding: 12px; margin: 10px 0; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; color: white; font-size: 1em;">
                    <option value="2">2 Teams</option>
                    <option value="3">3 Teams</option>
                    <option value="4">4 Teams</option>
                </select>
                <button class="btn" onclick="startGame()">Start Adventure!</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div class="game-over" id="gameOverScreen">
            <div class="game-over-content">
                <h1>üèÜ Game Over!</h1>
                <div class="final-scores" id="finalScores"></div>
                <button class="btn" onclick="location.reload()">Play Again</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let scene, camera, renderer, globe;
        let teams = [];
        let currentTeamIndex = 0;
        let currentTurn = 1;
        let maxTurns = 20;
        let questionTimer;
        let markers = [];
        let cityDots = [];
        let cityLabels = [];
        let teamLabels = [];
        let travelLines = [];
        let previewCurves = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let isLocalJob = false;
        let pendingDestination = null;
        let isAnimatingRotation = false;


		const locations = {
			// Europe
			reykjavik: { name: "Reykjavik, Iceland", lat: 64.1466, lon: -21.9426 },
			dublin: { name: "Dublin, Ireland", lat: 53.3498, lon: -6.2603 },
			belfast: { name: "Belfast, UK", lat: 54.5973, lon: -5.9301 },
			glasgow: { name: "Glasgow, UK", lat: 55.8642, lon: -4.2518 },
			edinburgh: { name: "Edinburgh, UK", lat: 55.9533, lon: -3.1883 },
			manchester: { name: "Manchester, UK", lat: 53.4808, lon: -2.2426 },
			london: { name: "London, UK", lat: 51.5074, lon: -0.1278 },
			bergen: { name: "Bergen, Norway", lat: 60.3913, lon: 5.3221 },
			oslo: { name: "Oslo, Norway", lat: 59.9139, lon: 10.7522 },
			gothenburg: { name: "Gothenburg, Sweden", lat: 57.7089, lon: 11.9746 },
			stockholm: { name: "Stockholm, Sweden", lat: 59.3293, lon: 18.0686 },
			helsinki: { name: "Helsinki, Finland", lat: 60.1699, lon: 24.9384 },
			copenhagen: { name: "Copenhagen, Denmark", lat: 55.6761, lon: 12.5683 },
			hamburg: { name: "Hamburg, Germany", lat: 53.5511, lon: 9.9937 },
			berlin: { name: "Berlin, Germany", lat: 52.5200, lon: 13.4050 },
			frankfurt: { name: "Frankfurt, Germany", lat: 50.1109, lon: 8.6821 },
			munich: { name: "Munich, Germany", lat: 48.1351, lon: 11.5820 },
			amsterdam: { name: "Amsterdam, Netherlands", lat: 52.3676, lon: 4.9041 },
			brussels: { name: "Brussels, Belgium", lat: 50.8503, lon: 4.3517 },
			paris: { name: "Paris, France", lat: 48.8566, lon: 2.3522 },
			marseille: { name: "Marseille, France", lat: 43.2965, lon: 5.3698 },
			zurich: { name: "Zurich, Switzerland", lat: 47.3769, lon: 8.5417 },
			geneva: { name: "Geneva, Switzerland", lat: 46.2044, lon: 6.1432 },
			milan: { name: "Milan, Italy", lat: 45.4642, lon: 9.1900 },
			rome: { name: "Rome, Italy", lat: 41.9028, lon: 12.4964 },
			naples: { name: "Naples, Italy", lat: 40.8518, lon: 14.2681 },
			vienna: { name: "Vienna, Austria", lat: 48.2082, lon: 16.3738 },
			prague: { name: "Prague, Czech Republic", lat: 50.0755, lon: 14.4378 },
			krakow: { name: "Krakow, Poland", lat: 50.0647, lon: 19.9450 },
			warsaw: { name: "Warsaw, Poland", lat: 52.2297, lon: 21.0122 },
			budapest: { name: "Budapest, Hungary", lat: 47.4979, lon: 19.0402 },
			lisbon: { name: "Lisbon, Portugal", lat: 38.7223, lon: -9.1393 },
			porto: { name: "Porto, Portugal", lat: 41.1579, lon: -8.6291 },
			madrid: { name: "Madrid, Spain", lat: 40.4168, lon: -3.7038 },
			barcelona: { name: "Barcelona, Spain", lat: 41.3851, lon: 2.1734 },
			athens: { name: "Athens, Greece", lat: 37.9838, lon: 23.7275 },
			istanbul: { name: "Istanbul, Turkey", lat: 41.0082, lon: 28.9784 },
			ankara: { name: "Ankara, Turkey", lat: 39.9334, lon: 32.8597 },
			kyiv: { name: "Kyiv, Ukraine", lat: 50.4501, lon: 30.5234 },
			moscow: { name: "Moscow, Russia", lat: 55.7558, lon: 37.6173 },
			stpetersburg: { name: "Saint Petersburg, Russia", lat: 59.9343, lon: 30.3351 },

			// Americas
			nuuk: { name: "Nuuk, Greenland", lat: 64.1836, lon: -51.7216 },
			anchorage: { name: "Anchorage, USA", lat: 61.2181, lon: -149.9003 },
			vancouver: { name: "Vancouver, Canada", lat: 49.2827, lon: -123.1207 },
			calgary: { name: "Calgary, Canada", lat: 51.0447, lon: -114.0719 },
			ottawa: { name: "Ottawa, Canada", lat: 45.4215, lon: -75.6972 },
			toronto: { name: "Toronto, Canada", lat: 43.6532, lon: -79.3832 },
			montreal: { name: "Montreal, Canada", lat: 45.5017, lon: -73.5673 },
			halifax: { name: "Halifax, Canada", lat: 44.6488, lon: -63.5752 },
			seattle: { name: "Seattle, USA", lat: 47.6062, lon: -122.3321 },
			sanfrancisco: { name: "San Francisco, USA", lat: 37.7749, lon: -122.4194 },
			losangeles: { name: "Los Angeles, USA", lat: 34.0522, lon: -118.2437 },
			sandiego: { name: "San Diego, USA", lat: 32.7157, lon: -117.1611 },
			lasvegas: { name: "Las Vegas, USA", lat: 36.1699, lon: -115.1398 },
			denver: { name: "Denver, USA", lat: 39.7392, lon: -104.9903 },
			dallas: { name: "Dallas, USA", lat: 32.7767, lon: -96.7970 },
			houston: { name: "Houston, USA", lat: 29.7604, lon: -95.3698 },
			chicago: { name: "Chicago, USA", lat: 41.8781, lon: -87.6298 },
			atlanta: { name: "Atlanta, USA", lat: 33.7490, lon: -84.3880 },
			miami: { name: "Miami, USA", lat: 25.7617, lon: -80.1918 },
			washingtondc: { name: "Washington D.C., USA", lat: 38.9072, lon: -77.0369 },
			philadelphia: { name: "Philadelphia, USA", lat: 39.9526, lon: -75.1652 },
			newyork: { name: "New York, USA", lat: 40.7128, lon: -74.0060 },
			boston: { name: "Boston, USA", lat: 42.3601, lon: -71.0589 },
			monterrey: { name: "Monterrey, Mexico", lat: 25.6866, lon: -100.3161 },
			mexicocity: { name: "Mexico City, Mexico", lat: 19.4326, lon: -99.1332 },
			havana: { name: "Havana, Cuba", lat: 23.1136, lon: -82.3666 },
			panamacity: { name: "Panama City, Panama", lat: 8.9833, lon: -79.5167 },
			bogota: { name: "Bogot√°, Colombia", lat: 4.7110, lon: -74.0721 },
			medellin: { name: "Medell√≠n, Colombia", lat: 6.2442, lon: -75.5812 },
			caracas: { name: "Caracas, Venezuela", lat: 10.4806, lon: -66.9036 },
			quito: { name: "Quito, Ecuador", lat: -0.1807, lon: -78.4678 },
			manaus: { name: "Manaus, Brazil", lat: -3.1190, lon: -60.0217 },
			lima: { name: "Lima, Peru", lat: -12.0464, lon: -77.0428 },
			cusco: { name: "Cusco, Peru", lat: -13.5320, lon: -71.9675 },
			lapaz: { name: "La Paz, Bolivia", lat: -16.4897, lon: -68.1193 },
			salvador: { name: "Salvador, Brazil", lat: -12.9777, lon: -38.5016 },
			riodejaneiro: { name: "Rio de Janeiro, Brazil", lat: -22.9068, lon: -43.1729 },
			saopaulo: { name: "S√£o Paulo, Brazil", lat: -23.5505, lon: -46.6333 },
			santiago: { name: "Santiago, Chile", lat: -33.4489, lon: -70.6693 },
			buenosaires: { name: "Buenos Aires, Argentina", lat: -34.6037, lon: -58.3816 },

			// Africa
			casablanca: { name: "Casablanca, Morocco", lat: 33.5731, lon: -7.5898 },
			marrakech: { name: "Marrakech, Morocco", lat: 31.6295, lon: -7.9811 },
			alexandria: { name: "Alexandria, Egypt", lat: 31.2001, lon: 29.9187 },
			cairo: { name: "Cairo, Egypt", lat: 30.0444, lon: 31.2357 },
			dakar: { name: "Dakar, Senegal", lat: 14.7167, lon: -17.4677 },
			accra: { name: "Accra, Ghana", lat: 5.6037, lon: -0.1870 },
			lagos: { name: "Lagos, Nigeria", lat: 6.5244, lon: 3.3792 },
			addisababa: { name: "Addis Ababa, Ethiopia", lat: 9.0300, lon: 38.7400 },
			mombasa: { name: "Mombasa, Kenya", lat: -4.0435, lon: 39.6682 },
			nairobi: { name: "Nairobi, Kenya", lat: -1.2921, lon: 36.8219 },
			daressalaam: { name: "Dar es Salaam, Tanzania", lat: -6.7924, lon: 39.2083 },
			kinshasa: { name: "Kinshasa, DRC", lat: -4.4419, lon: 15.2663 },
			johannesburg: { name: "Johannesburg, South Africa", lat: -26.2041, lon: 28.0473 },
			capetown: { name: "Cape Town, South Africa", lat: -33.9249, lon: 18.4241 },
			antananarivo: { name: "Antananarivo, Madagascar", lat: -18.8792, lon: 47.5079 },

			// Asia & Middle East
			jerusalem: { name: "Jerusalem, Israel", lat: 31.7683, lon: 35.2137 },
			jeddah: { name: "Jeddah, Saudi Arabia", lat: 21.4858, lon: 39.1925 },
			riyadh: { name: "Riyadh, Saudi Arabia", lat: 24.7136, lon: 46.6753 },
			dubai: { name: "Dubai, UAE", lat: 25.2048, lon: 55.2708 },
			tehran: { name: "Tehran, Iran", lat: 35.6892, lon: 51.3890 },
			baghdad: { name: "Baghdad, Iraq", lat: 33.3152, lon: 44.3661 },
			karachi: { name: "Karachi, Pakistan", lat: 24.8607, lon: 67.0011 },
			mumbai: { name: "Mumbai, India", lat: 19.0760, lon: 72.8777 },
			bangalore: { name: "Bangalore, India", lat: 12.9716, lon: 77.5946 },
			chennai: { name: "Chennai, India", lat: 13.0827, lon: 80.2707 },
			newdelhi: { name: "New Delhi, India", lat: 28.6139, lon: 77.2090 },
			kolkata: { name: "Kolkata, India", lat: 22.5726, lon: 88.3639 },
			dhaka: { name: "Dhaka, Bangladesh", lat: 23.8103, lon: 90.4125 },
			tashkent: { name: "Tashkent, Uzbekistan", lat: 41.2995, lon: 69.2401 },
			bangkok: { name: "Bangkok, Thailand", lat: 13.7563, lon: 100.5018 },
			hochiminh: { name: "Ho Chi Minh City, Vietnam", lat: 10.7769, lon: 106.7009 },
			hanoi: { name: "Hanoi, Vietnam", lat: 21.0285, lon: 105.8542 },
			singapore: { name: "Singapore", lat: 1.3521, lon: 103.8198 },
			kualalumpur: { name: "Kuala Lumpur, Malaysia", lat: 3.1390, lon: 101.6869 },
			jakarta: { name: "Jakarta, Indonesia", lat: -6.2088, lon: 106.8456 },
			manila: { name: "Manila, Philippines", lat: 14.5995, lon: 120.9842 },
			guangzhou: { name: "Guangzhou, China", lat: 23.1291, lon: 113.2644 },
			shenzhen: { name: "Shenzhen, China", lat: 22.5431, lon: 114.0579 },
			hongkong: { name: "Hong Kong", lat: 22.3193, lon: 114.1694 },
			shanghai: { name: "Shanghai, China", lat: 31.2304, lon: 121.4737 },
			chengdu: { name: "Chengdu, China", lat: 30.5728, lon: 104.0668 },
			beijing: { name: "Beijing, China", lat: 39.9042, lon: 116.4074 },
			seoul: { name: "Seoul, South Korea", lat: 37.5665, lon: 126.9780 },
			busan: { name: "Busan, South Korea", lat: 35.1796, lon: 129.0756 },
			sapporo: { name: "Sapporo, Japan", lat: 43.0618, lon: 141.3545 },
			tokyo: { name: "Tokyo, Japan", lat: 35.6762, lon: 139.6503 },
			osaka: { name: "Osaka, Japan", lat: 34.6937, lon: 135.5023 },
			vladivostok: { name: "Vladivostok, Russia", lat: 43.1332, lon: 131.9113 },
            astana:            { name: "Astana, Kazakhstan",           lat: 51.1605, lon:  71.4704 },
            almaty:            { name: "Almaty, Kazakhstan",           lat: 43.2220, lon:  76.8512 },
            bishkek:           { name: "Bishkek, Kyrgyzstan",          lat: 42.8746, lon:  74.5698 },
            dushanbe:          { name: "Dushanbe, Tajikistan",         lat: 38.5610, lon:  68.7730 },
            ashgabat:          { name: "Ashgabat, Turkmenistan",       lat: 37.9601, lon:  58.3261 },

            /* South Asia ‚Äì Himalaya & Subkontinenten */
            kathmandu:         { name: "Kathmandu, Nepal",             lat: 27.7172, lon:  85.3240 },
            pokhara:           { name: "Pokhara, Nepal",               lat: 28.2096, lon:  83.9856 },
            colombo:           { name: "Colombo, Sri Lanka",           lat:  6.9271, lon:  79.8612 },
            kandy:             { name: "Kandy, Sri Lanka",             lat:  7.2906, lon:  80.6337 },
            thimphu:           { name: "Thimphu, Bhutan",              lat: 27.4728, lon:  89.6390 },
            male:              { name: "Male, Maldives",               lat:  4.1755, lon:  73.5093 },

            /* Afghanistan ‚Äì Pakistan */
            kabul:             { name: "Kabul, Afghanistan",           lat: 34.5553, lon:  69.2075 },
            herat:             { name: "Herat, Afghanistan",           lat: 34.3482, lon:  62.1997 },
            islamabad:         { name: "Islamabad, Pakistan",          lat: 33.6844, lon:  73.0479 },
            lahore:            { name: "Lahore, Pakistan",             lat: 31.5204, lon:  74.3587 },
            peshawar:          { name: "Peshawar, Pakistan",           lat: 34.0151, lon:  71.5805 },
            quetta:            { name: "Quetta, Pakistan",             lat: 30.1798, lon:  66.9750 },

            /* India ‚Äì fler mega- & mellanst√§der */
            hyderabad:         { name: "Hyderabad, India",             lat: 17.3850, lon:  78.4867 },
            pune:              { name: "Pune, India",                  lat: 18.5204, lon:  73.8567 },
            ahmedabad:         { name: "Ahmedabad, India",             lat: 23.0225, lon:  72.5714 },
            jaipur:            { name: "Jaipur, India",                lat: 26.9124, lon:  75.7873 },
            kochi:             { name: "Kochi, India",                 lat:  9.9312, lon:  76.2673 },
            goa:               { name: "Panaji (Goa), India",          lat: 15.4909, lon:  73.8278 },
            lucknow:           { name: "Lucknow, India",               lat: 26.8467, lon:  80.9462 },

            /* Bangladesh */
            chittagong:        { name: "Chattogram, Bangladesh",       lat: 22.3569, lon:  91.7832 },
            sylhet:            { name: "Sylhet, Bangladesh",           lat: 24.8949, lon:  91.8687 },

            /* Mainland Southeast Asia */
            yangon:            { name: "Yangon, Myanmar",              lat: 16.8409, lon:  96.1735 },
            mandalay:          { name: "Mandalay, Myanmar",            lat: 21.9162, lon:  95.9550 },
            chiangmai:         { name: "Chiang Mai, Thailand",         lat: 18.7883, lon:  98.9853 },
            phuket:            { name: "Phuket, Thailand",             lat:  7.8804, lon:  98.3923 },
            vientiane:         { name: "Vientiane, Laos",              lat: 17.9757, lon: 102.6331 },
            luangprabang:      { name: "Luang Prabang, Laos",          lat: 19.8860, lon: 102.1350 },
            phnompenh:         { name: "Phnom Penh, Cambodia",         lat: 11.5449, lon: 104.8922 },
            siemreap:          { name: "Siem Reap, Cambodia",          lat: 13.3671, lon: 103.8440 },

            /* Vietnam */
            danang:            { name: "Da Nang, Vietnam",             lat: 16.0471, lon: 108.2068 },
            hue:               { name: "Hue, Vietnam",                 lat: 16.4637, lon: 107.5909 },

            /* Maritime Southeast Asia */
            georgetown:        { name: "George Town, Malaysia",        lat:  5.4124, lon: 100.3364 },
            johorbahru:        { name: "Johor Bahru, Malaysia",        lat:  1.4927, lon: 103.7414 },
            kotakinabalu:      { name: "Kota Kinabalu, Malaysia",      lat:  5.9804, lon: 116.0735 },
            kuching:           { name: "Kuching, Malaysia",            lat:  1.5535, lon: 110.3592 },
            bandarseribegawan: { name: "Bandar Seri Begawan, Brunei",  lat:  4.9031, lon: 114.9398 },
            surabaya:          { name: "Surabaya, Indonesia",          lat: -7.2575, lon: 112.7521 },
            bandung:           { name: "Bandung, Indonesia",           lat: -6.9175, lon: 107.6191 },
            yogyakarta:        { name: "Yogyakarta, Indonesia",        lat: -7.7956, lon: 110.3695 },
            denpasar:          { name: "Denpasar (Bali), Indonesia",   lat: -8.6500, lon: 115.2167 },
            medan:             { name: "Medan, Indonesia",             lat:  3.5952, lon:  98.6722 },
            makassar:          { name: "Makassar, Indonesia",          lat: -5.1477, lon: 119.4327 },
            balikpapan:        { name: "Balikpapan, Indonesia",        lat: -1.2654, lon: 116.8312 },
            manado:            { name: "Manado, Indonesia",            lat:  1.4748, lon: 124.8421 },
            cebucity:          { name: "Cebu City, Philippines",       lat: 10.3157, lon: 123.8854 },
            davaocity:         { name: "Davao City, Philippines",      lat:  7.1907, lon: 125.4553 },
            iloilocity:        { name: "Iloilo City, Philippines",     lat: 10.7202, lon: 122.5621 },

            /* Greater China */
            wuhan:             { name: "Wuhan, China",                 lat: 30.5928, lon: 114.3055 },
            xian:              { name: "Xi'an, China",                 lat: 34.3416, lon: 108.9398 },
            hangzhou:          { name: "Hangzhou, China",              lat: 30.2741, lon: 120.1551 },
            nanjing:           { name: "Nanjing, China",               lat: 32.0603, lon: 118.7969 },
            suzhou:            { name: "Suzhou, China",                lat: 31.2989, lon: 120.5853 },
            chongqing:         { name: "Chongqing, China",             lat: 29.4316, lon: 106.9123 },
            tianjin:           { name: "Tianjin, China",               lat: 39.0842, lon: 117.2009 },
            harbin:            { name: "Harbin, China",                lat: 45.8038, lon: 126.5349 },
            kunming:           { name: "Kunming, China",               lat: 25.0389, lon: 102.7183 },
            xiamen:            { name: "Xiamen, China",                lat: 24.4798, lon: 118.0894 },
            qingdao:           { name: "Qingdao, China",               lat: 36.0671, lon: 120.3826 },
            urumqi:            { name: "√úr√ºmqi, China",                lat: 43.8256, lon:  87.6169 },
            lhasa:             { name: "Lhasa, China (Tibet)",         lat: 29.6520, lon:  91.1721 },
            taipei:            { name: "Taipei, Taiwan",               lat: 25.0330, lon: 121.5654 },
            kaohsiung:         { name: "Kaohsiung, Taiwan",            lat: 22.6273, lon: 120.3014 },

            /* Koreas */
            pyongyang:         { name: "Pyongyang, North Korea",       lat: 39.0392, lon: 125.7625 },
            incheon:           { name: "Incheon, South Korea",         lat: 37.4563, lon: 126.7052 },
            daegu:             { name: "Daegu, South Korea",           lat: 35.8722, lon: 128.6014 },
            daejeon:           { name: "Daejeon, South Korea",         lat: 36.3504, lon: 127.3845 },
            gwangju:           { name: "Gwangju, South Korea",         lat: 35.1595, lon: 126.8526 },
            jeju:              { name: "Jeju City, South Korea",       lat: 33.4996, lon: 126.5312 },

            /* Japan ‚Äì fler p√§rlor */
            nagoya:            { name: "Nagoya, Japan",                lat: 35.1815, lon: 136.9066 },
            kyoto:             { name: "Kyoto, Japan",                 lat: 35.0116, lon: 135.7681 },
            fukuoka:           { name: "Fukuoka, Japan",               lat: 33.5904, lon: 130.4017 },
            yokohama:          { name: "Yokohama, Japan",              lat: 35.4437, lon: 139.6380 },
            hiroshima:         { name: "Hiroshima, Japan",             lat: 34.3853, lon: 132.4553 },
            sendai:            { name: "Sendai, Japan",                lat: 38.2682, lon: 140.8694 },
            naha:              { name: "Naha (Okinawa), Japan",        lat: 26.2124, lon: 127.6809 },

            /* Mongolia & Siberia */
            ulaanbaatar:       { name: "Ulaanbaatar, Mongolia",        lat: 47.8864, lon: 106.9057 },
            novosibirsk:       { name: "Novosibirsk, Russia",          lat: 55.0084, lon:  82.9357 },
            irkutsk:           { name: "Irkutsk, Russia",              lat: 52.2871, lon: 104.2830 },
            yakutsk:           { name: "Yakutsk, Russia",              lat: 62.0355, lon: 129.6755 },

            /* Gulf & Levant ‚Äì desert detours */
            abudhabi:          { name: "Abu Dhabi, UAE",               lat: 24.4539, lon:  54.3773 },
            sharjah:           { name: "Sharjah, UAE",                 lat: 25.3463, lon:  55.4209 },
            doha:              { name: "Doha, Qatar",                  lat: 25.2854, lon:  51.5310 },
            manama:            { name: "Manama, Bahrain",              lat: 26.2235, lon:  50.5876 },
            kuwaitcity:        { name: "Kuwait City, Kuwait",          lat: 29.3759, lon:  47.9774 },
            muscat:            { name: "Muscat, Oman",                 lat: 23.5880, lon:  58.3829 },
            salalah:           { name: "Salalah, Oman",                lat: 17.0193, lon:  54.0894 },
            mecca:             { name: "Mecca, Saudi Arabia",          lat: 21.3891, lon:  39.8579 },
            medina:            { name: "Medina, Saudi Arabia",         lat: 24.5247, lon:  39.5692 },
            isfahan:           { name: "Isfahan, Iran",                lat: 32.6539, lon:  51.6660 },
            shiraz:            { name: "Shiraz, Iran",                 lat: 29.5918, lon:  52.5837 },
            mashhad:           { name: "Mashhad, Iran",                lat: 36.2605, lon:  59.6168 },
            tabriz:            { name: "Tabriz, Iran",                 lat: 38.0962, lon:  46.2738 },
            basra:             { name: "Basra, Iraq",                  lat: 30.5085, lon:  47.7804 },
            izmir:             { name: "Izmir, Turkey",                lat: 38.4237, lon:  27.1428 },
            antalya:           { name: "Antalya, Turkey",              lat: 36.8969, lon:  30.7133 },
            beirut:            { name: "Beirut, Lebanon",              lat: 33.8938, lon:  35.5018 },
            damascus:          { name: "Damascus, Syria",              lat: 33.5138, lon:  36.2765 },
            aleppo:            { name: "Aleppo, Syria",                lat: 36.2021, lon:  37.1343 },
            amman:             { name: "Amman, Jordan",                lat: 31.9539, lon:  35.9106 },
            sanaa:             { name: "Sana'a, Yemen",                lat: 15.3694, lon:  44.1910 },
            aden:              { name: "Aden, Yemen",                  lat: 12.7855, lon:  45.0187 },
            tbilisi:           { name: "Tbilisi, Georgia",             lat: 41.7151, lon:  44.8271 },
            baku:              { name: "Baku, Azerbaijan",             lat: 40.4093, lon:  49.8671 },
            yerevan:           { name: "Yerevan, Armenia",             lat: 40.1792, lon:  44.4991 },

			
			// Oceania & Pacific Islands
			perth: { name: "Perth, Australia", lat: -31.9505, lon: 115.8605 },
			adelaide: { name: "Adelaide, Australia", lat: -34.9285, lon: 138.6007 },
			melbourne: { name: "Melbourne, Australia", lat: -37.8136, lon: 144.9631 },
			brisbane: { name: "Brisbane, Australia", lat: -27.4698, lon: 153.0251 },
			sydney: { name: "Sydney, Australia", lat: -33.8688, lon: 151.2093 },
			wellington: { name: "Wellington, New Zealand", lat: -41.2865, lon: 174.7762 },
			auckland: { name: "Auckland, New Zealand", lat: -36.8485, lon: 174.7633 },
			suva: { name: "Suva, Fiji", lat: -18.1416, lon: 178.4419 },
			honolulu: { name: "Honolulu, USA", lat: 21.3069, lon: -157.8583 }
		};
		
		/* ---------------------------------------------
		 * Gemini 2.5 Flash helper
		 * --------------------------------------------- */
		const GEMINI_MODEL_ID = 'gemini-2.5-flash';

		function getGeminiApiKey() {
		  let key = localStorage.getItem('gemini_api_key');
		  if (!key) {
			key = prompt('Enter your Gemini API key');
			if (key) localStorage.setItem('gemini_api_key', key);
		  }
		  return key;
		}

		// Tiny shortcut for changing the key (Ctrl + K)
		document.addEventListener('keydown', (e) => {
		  if (e.ctrlKey && e.key.toLowerCase() === 'k') {
			localStorage.removeItem('gemini_api_key');
			alert('Gemini key cleared ÔøΩ youÔøΩll be prompted again on the next turn.');
		  }
		});

        /* -------------------------------------------------
        * Gemini 2.5 Flash helper  ‚Äì  verbose debug edition
        * ------------------------------------------------- */
        /* -------------------------------------------------
        * Gemini 2.5 Flash helper ‚Äì array-aware, resilient
        * ------------------------------------------------- */
        async function geminiStreamJSON(promptText, _retry = false) {
        const apiKey = getGeminiApiKey();
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_ID}:streamGenerateContent?key=${apiKey}`;

        const payload = {
            contents: [{ role: 'user', parts: [{ text: promptText }] }],
            generationConfig: { responseMimeType: 'text/plain' }  // safest
        };

        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(`Gemini error: ${res.status}`);

        /* Read full stream into one big string */
        const reader  = res.body.getReader();
        const decoder = new TextDecoder();
        let raw = '';
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            raw += decoder.decode(value, { stream: true });
        }

        /* -------- 1Ô∏è‚É£ try: raw string is already a JSON array -------- */
        try {
            const arr = JSON.parse(raw.trim());        // may throw
            const combined = arr
            .map(o => o?.candidates?.[0]?.content?.parts?.[0]?.text ?? '')
            .join('');
            return extractInnerJSON(combined);
        } catch (e1) {
            console.warn('[gemini] array parse failed:', e1);
        }

        /* -------- 2Ô∏è‚É£ try: crop from first { to last } in raw -------- */
        try {
            const cropped = raw.slice(raw.indexOf('{'), raw.lastIndexOf('}') + 1);
            const obj     = JSON.parse(cropped);
            const firstText = obj?.candidates?.[0]?.content?.parts?.[0]?.text ?? '';
            return extractInnerJSON(firstText);
        } catch (e2) {
            if (!_retry) {
            console.warn('[gemini] brace-crop parse failed ‚Äì retrying once‚Ä¶', e2);
            return geminiStreamJSON(promptText, true);
            }
            throw e2;   // generateQuestion() will fall back
        }
        }

        /* Helper: strip ``` fences & parse the embedded JSON */
        function extractInnerJSON(text) {
        // remove ```json ‚Ä¶ ``` or ``` ‚Ä¶ ```
        const cleaned = text.replace(/```json|```/gi, '').trim();
        const first   = cleaned.indexOf('{');
        const last    = cleaned.lastIndexOf('}');
        const jsonStr = cleaned.slice(first, last + 1);
        const data    = JSON.parse(jsonStr);

        // final sanity check
        if (!data?.question || !Array.isArray(data.answers) || data.answers.length !== 4)
            throw new Error('Malformed trivia JSON');
        return JSON.stringify(data);   // generateQuestion() immediately JSON.parse(...)s it
        }

        // Transportation logic based on distance
        function getTransport(distance) {
            if (distance < 50) return { icon: 'üö∂', name: 'Walking', cost: 0 };
            if (distance < 150) return { icon: 'üö¥', name: 'Bicycle', cost: 20 + Math.floor(distance / 3) };
            if (distance < 300) return { icon: 'üöå', name: 'Bus', cost: 50 + Math.floor(distance / 4) };
            if (distance < 600) return { icon: 'üöó', name: 'Car', cost: 100 + Math.floor(distance / 4) };
            if (distance < 1000) return { icon: 'üöÇ', name: 'Train', cost: 200 + Math.floor(distance / 5) };
            if (distance < 2000) return { icon: 'üõ•Ô∏è', name: 'Ferry', cost: 300 + Math.floor(distance / 6) };
            if (distance < 4000) return { icon: '‚úàÔ∏è', name: 'Regional Flight', cost: 500 + Math.floor(distance / 8) };
            return { icon: '‚úàÔ∏è', name: 'International Flight', cost: 800 + Math.floor(distance / 10) };
        }

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000814);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0.5, 2.5); // Slightly elevated view
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lighting - more ambient light to ensure globe is visible
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Create globe with simple color for now
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            
            // Create a simple blue/green globe material
            const material = new THREE.MeshPhongMaterial({
                color: 0x2a5298,
                emissive: 0x112244,
                shininess: 10,
                specular: 0x222222
            });

            globe = new THREE.Mesh(geometry, material);
            
            // Initial rotation to show Stockholm/Europe properly
            // Stockholm is at 18¬∞E, so we need -(18 + 90) to center it
            globe.rotation.y = -(18 + 90) * (Math.PI / 180);
            globe.rotation.x = -0.1; // Slight tilt down
            
            scene.add(globe);

            // Try to load Earth texture (but don't fail if it doesn't work)
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
                (texture) => {
                    globe.material.map = texture;
                    globe.material.needsUpdate = true;
                },
                undefined,
                (error) => {
                    console.log('Earth texture failed to load, using fallback color');
                }
            );

            // Add stars
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.02,
                transparent: true,
                opacity: 0.8
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = -Math.random() * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);

            // Touch/mouse rotation
            function handleStart(event) {
                isDragging = true;
                if (event.touches) {
                    previousMousePosition = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                } else {
                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }
            }

            function handleMove(event) {
                if (!isDragging) return;

                let currentMousePosition;
                if (event.touches) {
                    currentMousePosition = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                } else {
                    currentMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }

                const deltaMove = {
                    x: currentMousePosition.x - previousMousePosition.x,
                    y: currentMousePosition.y - previousMousePosition.y
                };

                globe.rotation.y += deltaMove.x * 0.005;
                globe.rotation.x += deltaMove.y * 0.005;

                previousMousePosition = currentMousePosition;
            }

            function handleEnd() {
                isDragging = false;
            }

            renderer.domElement.addEventListener('mousedown', handleStart);
            renderer.domElement.addEventListener('mousemove', handleMove);
            renderer.domElement.addEventListener('mouseup', handleEnd);
            renderer.domElement.addEventListener('touchstart', handleStart);
            renderer.domElement.addEventListener('touchmove', handleMove);
            renderer.domElement.addEventListener('touchend', handleEnd);

            window.addEventListener('resize', onWindowResize);
        }

        // Add city dot with label for major cities
        function addCityDot(lat, lon, name = null, isImportant = false) {
            const position = latLonToVector3(lat, lon, 1.005);
            
            const dotGeometry = new THREE.SphereGeometry(isImportant ? 0.008 : 0.005, 8, 8);
            const dotMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                opacity: isImportant ? 0.9 : 0.6,
                transparent: true
            });
            const dot = new THREE.Mesh(dotGeometry, dotMaterial);
            dot.position.copy(position);
            
            // Add as child of globe
            globe.add(dot);
            cityDots.push(dot);
            
            // Add label for important cities
            if (name && isImportant) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'bold 32px Arial'; // Increased from 24px
                context.fillStyle = 'white';
                context.strokeStyle = 'black';
                context.lineWidth = 2;
                context.textAlign = 'center';
                context.strokeText(name, 128, 40);
                context.fillText(name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                const labelPosition = latLonToVector3(lat, lon, 1.12); // Slightly further out
                sprite.position.copy(labelPosition);
                sprite.scale.set(0.4, 0.1, 1); // Increased scale
                
                globe.add(sprite);
                cityLabels.push(sprite);
            }
            
            return dot;
        }

        // Update team labels
        function updateTeamLabels() {
            // Remove old team labels
            teamLabels.forEach(label => globe.remove(label));
            teamLabels = [];
            
            // Add new team labels
            teams.forEach((team, index) => {
                const location = locations[team.currentLocation];
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 320; // Increased canvas size
                canvas.height = 80;
                
                context.font = 'bold 36px Arial'; // Increased from 28px
                context.fillStyle = getTeamColorHex(index);
                context.strokeStyle = 'black';
                context.lineWidth = 4;
                context.textAlign = 'center';
                context.strokeText(team.name, 160, 50);
                context.fillText(team.name, 160, 50);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                const labelPosition = latLonToVector3(location.lat, location.lon, 1.18); // Further out
                sprite.position.copy(labelPosition);
                sprite.scale.set(0.5, 0.125, 1); // Increased scale
                
                globe.add(sprite);
                teamLabels.push(sprite);
            });
        }

        // Get team color as hex string
        function getTeamColorHex(index) {
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
            return colors[index % colors.length];
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Setup team selection
        document.getElementById('teamCount').addEventListener('change', (e) => {
            const count = parseInt(e.target.value);
            const container = document.getElementById('teamSetupContainer');
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                container.innerHTML += `
                    <div class="team-setup">
                        <label>Team ${i + 1} Name:</label>
                        <input type="text" id="team${i + 1}Name" placeholder="Enter team name" value="Team ${i + 1}">
                    </div>
                `;
            }
        });

        // Start game
        function startGame() {
            const teamCount = parseInt(document.getElementById('teamCount').value);
            teams = [];
            
            for (let i = 0; i < teamCount; i++) {
                const teamName = document.getElementById(`team${i + 1}Name`).value || `Team ${i + 1}`;
                teams.push({
                    name: teamName,
                    money: 1000,
                    totalDistance: 0,
                    currentLocation: 'stockholm',
                    locations: ['stockholm']
                });
            }

            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('header').style.display = 'flex';
            document.getElementById('locationInfo').style.display = 'block';
            
            // Add city dots and labels for major cities
            const majorCities = ['stockholm', 'london', 'paris', 'newyork', 'tokyo', 'sydney', 'beijing', 'moscow', 'cairo', 'riodejaneiro'];
            
            Object.entries(locations).forEach(([key, location]) => {
                const isImportant = majorCities.includes(key);
                const displayName = isImportant ? location.name.split(',')[0] : null;
                addCityDot(location.lat, location.lon, displayName, isImportant);
            });
            
            updateUI();
            
            // Add starting marker for each team
            teams.forEach((team, index) => {
                const color = getTeamColor(index);
                addLocationMarker(locations.stockholm.lat, locations.stockholm.lon, color);
            });
            
            updateTeamLabels();
            focusGlobeOnLocation(locations.stockholm);
            
            // Start with travel options instead of question
            setTimeout(() => showTravelOptions(), 1000);
        }

        // Get team color
        function getTeamColor(index) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            return colors[index % colors.length];
        }

        // Update UI
        function updateUI() {
            const teamInfoContainer = document.getElementById('teamInfoContainer');
            teamInfoContainer.innerHTML = '';
            
            teams.forEach((team, index) => {
                const isActive = index === currentTeamIndex;
                const currentLoc = locations[team.currentLocation];
                teamInfoContainer.innerHTML += `
                    <div class="team-info" style="${isActive ? 'background: rgba(74, 222, 128, 0.2); border-color: #4ade80;' : ''}">
                        <div class="team-name">${team.name}</div>
                        <div class="team-money">üí∞ $${team.money}</div>
                        <div class="team-distance">üìç ${Math.round(team.totalDistance)} km</div>
                        <div class="team-location">üìå ${currentLoc.name}</div>
                    </div>
                `;
            });
            
            document.getElementById('currentTurn').textContent = currentTurn;
            document.getElementById('maxTurns').textContent = maxTurns;
            document.getElementById('turnsLeft').textContent = maxTurns - currentTurn;
            
            // Show current team's location
            const currentTeam = teams[currentTeamIndex];
            document.getElementById('locationName').textContent = locations[currentTeam.currentLocation].name;
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Generate AI question (Gemini 2.5 Flash)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function generateQuestion() {
        const currentTeam = teams[currentTeamIndex];

        /* Which city should inspire the quiz?
            ‚Äì If the team has already bought a ticket this turn, use THAT destination;
            ‚Äì otherwise use the place where they‚Äôre currently standing. */
        const activeLocation = pendingDestination
                ? locations[pendingDestination.key]
                : locations[currentTeam.currentLocation];

        // Pick a random category & difficulty
        const themes = ['Geography', 'History', 'Culture', 'Science', 'Sports',
                        'Entertainment', 'Food', 'Architecture', 'Nature', 'Economy'];
        const theme = themes[Math.floor(Math.random() * themes.length)];
        // ‚Äúa little bit difficult‚Äù by default; crank it up for local-job challenges

        const lowestDistance = Math.min(...teams.map(t => t.totalDistance));

        let difficulty;

        if (currentTeam.totalDistance === lowestDistance) {
            // L√§gst distans? Hj√§lp balansera med en mellansv√•r fr√•ga
            difficulty = 'medium';
        } else {
            // Annars 50/50 mellan medium och medium-hard
            difficulty = Math.random() < 0.5 ? 'medium' : 'medium-hard';
        }

        // Strict JSON-only contract for Gemini
        const prompt = `Generate a ${difficulty} trivia question. \
        The subject matter MUST be clearly connected to ${activeLocation.name} \
        (history, geography, culture, famous events, etc.). \
        Category: ${theme}. Respond **only** with JSON:
        {
        "question": "‚Ä¶",
        "answers": ["A","B","C","D"],
        "correct": 0,
        "theme": "${theme}"
        }
        Rules:
        - Exactly four answers.
        - Randomise which index is correct (0‚Äì3).
        - Family-friendly.
        - No extra text outside the JSON.`;

        try {
            const responseText = await geminiStreamJSON(prompt);
            const parsed = JSON.parse(responseText);
            if (
            parsed?.question &&
            Array.isArray(parsed.answers) && parsed.answers.length === 4 &&
            Number.isInteger(parsed.correct) && parsed.correct >= 0 && parsed.correct <= 3
            ) {
            return parsed;
            }
        } catch (err) {
            console.error('Gemini failed ‚Üí using fallback', err);
        }

        /* ===== fallback pool (unchanged) ===== */
        const fallback = [
            { question: 'What is the largest planet in our solar system?',
            answers: ['Jupiter', 'Saturn', 'Neptune', 'Earth'], correct: 0 },
            // ‚Ä¶ keep the rest of your hard-coded questions ‚Ä¶
        ];
        const q = fallback[Math.floor(Math.random() * fallback.length)];
        // shuffle answers so the correct index moves
        const shuffled = q.answers.slice();
        const correctAns = shuffled[q.correct];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return {
            question: q.question,
            answers: shuffled,
            correct: shuffled.indexOf(correctAns),
            theme: 'General Knowledge'
        };
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Show question UI
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function showQuestion() {
        const question = await generateQuestion();
        window.lastQuestion = question; // Store for answer checking

        const panel       = document.getElementById('questionPanel');
        const questionTxt = document.getElementById('questionText');
        const answersGrid = document.getElementById('answersGrid');

        if (isLocalJob) {
            questionTxt.innerHTML =
            `<div style="color:#3b82f6;margin-bottom:10px;">üíº LOCAL JOB CHALLENGE</div>${question.question}`;
        } else {
            questionTxt.textContent = question.question;
        }

        answersGrid.innerHTML = '';

        question.answers.forEach((answer, idx) => {
            const btn = document.createElement('button');
            btn.className = 'answer-btn';
            btn.textContent = answer;
            btn.onclick = (e) => checkAnswer(idx === question.correct, e.target);
            answersGrid.appendChild(btn);
        });

        panel.classList.add('active');
        startTimer();
        }

        // Timer
        function startTimer() {
            let timeLeft = 120;
            document.getElementById('timer').textContent = timeLeft;
            
            questionTimer = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(questionTimer);
                    checkAnswer(false, null);
                }
            }, 1000);
        }

        // Check answer
        function checkAnswer(isCorrect, clickedButton) {
            clearInterval(questionTimer);
            
            const currentTeam = teams[currentTeamIndex];
            const buttons = document.querySelectorAll('.answer-btn');
            
            buttons.forEach(btn => btn.disabled = true);
            
            // Store the correct answer button for highlighting
            let correctButton = null;
            buttons.forEach((btn, index) => {
                if (index === window.lastQuestion.correct) {
                    correctButton = btn;
                }
            });
            
            if (isLocalJob) {
                if (isCorrect) {
                    const earnings = 400 + Math.floor(Math.random() * 400); // $400-800
                    currentTeam.money += earnings;
                    if (clickedButton) clickedButton.classList.add('correct');
                } else {
                    const earnings = 100; // Minimum earnings for trying
                    currentTeam.money += earnings;
                    if (clickedButton) clickedButton.classList.add('incorrect');
                }
                isLocalJob = false;
            } else if (pendingDestination) {
                // Travel question
                if (isCorrect) {
                    const alreadyVisited = currentTeam.locations.includes(pendingDestination.key);
                    if (!alreadyVisited) currentTeam.money += 300; // Bonus for correct answer
                    if (clickedButton) clickedButton.classList.add('correct');
                    
                    // Execute the travel
                    currentTeam.totalDistance += pendingDestination.distance;
                    currentTeam.locations.push(pendingDestination.key);
                    
                    // Draw travel line
                    drawTravelLine(
                        locations[currentTeam.currentLocation], 
                        locations[pendingDestination.key],
                        getTeamColor(currentTeamIndex)
                    );
                    
                    // Update current location
                    currentTeam.currentLocation = pendingDestination.key;
                    
                    // Add marker for new location
                    addLocationMarker(
                        locations[pendingDestination.key].lat, 
                        locations[pendingDestination.key].lon, 
                        getTeamColor(currentTeamIndex)
                    );
                    
                    // Focus globe on new location
                    focusGlobeOnLocation(locations[pendingDestination.key]);
                } else {
                    // Wrong answer - stay in place but still pay
                    if (clickedButton) clickedButton.classList.add('incorrect');
                }
                
                pendingDestination = null;
            } else {
                // Regular question
                if (isCorrect) {
                    currentTeam.money += 500;
                    if (clickedButton) clickedButton.classList.add('correct');
                } else {
                    currentTeam.money += 100; // Consolation prize
                    if (clickedButton) clickedButton.classList.add('incorrect');
                }
            }
            
            // Blink the correct answer if user was wrong
            if (correctButton && !isCorrect) {
                let blinkCount = 0;
                const blinkInterval = setInterval(() => {
                    correctButton.classList.toggle('correct');
                    blinkCount++;
                    if (blinkCount >= 6) { // Blink 3 times
                        clearInterval(blinkInterval);
                        correctButton.classList.add('correct');
                    }
                }, 300);
            }
            
            updateUI();
            updateTeamLabels();
            
            setTimeout(() => {
                document.getElementById('questionPanel').classList.remove('active');
                nextTurn();
            }, 3000); // Increased delay to see the correct answer
        }

        // Take local job
        function takeLocalJob() {
            // Clear preview curves
            previewCurves.forEach(curve => globe.remove(curve));
            previewCurves = [];
            
            document.getElementById('travelOptions').classList.remove('active');
            isLocalJob = true;
            showQuestion();
        }

       // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //  Travel options ‚Üí always at least one WEST and one EAST pick
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function showTravelOptions() {
            const currentTeam   = teams[currentTeamIndex];
            const here          = locations[currentTeam.currentLocation];

            const ticketsGrid   = document.getElementById('ticketsGrid');
            ticketsGrid.innerHTML = '';

            /* -----------------------------------------
            * Helper: normalise Œîlon to the range ‚Äì180‚Ä¶+180
            * ----------------------------------------- */
            const deltaLon = (lonA, lonB) => {
                let d = lonA - lonB;
                if (d >  180) d -= 360;
                if (d < -180) d += 360;
                return d;              // west  ‚á¢  negative,  east ‚á¢  positive
            };

            /* -----------------------------------------
            * 1) Build master list (as before)
            * ----------------------------------------- */
            const all = Object.entries(locations)
                .filter(([key]) => key !== currentTeam.currentLocation)
                .map(([key, dest]) => {
                    const alreadyVisited = currentTeam.locations.includes(key);
                    const distance  = calculateDistance(here.lat, here.lon, dest.lat, dest.lon);
                    const transport = getTransport(distance);
                    return {
                        key,
                        destination: dest,
                        distance,
                        transport,
                        cost: transport.cost,
                        visited: alreadyVisited,
                        canAfford: currentTeam.money >= transport.cost,
                        isWest:  deltaLon(dest.lon, here.lon) < 0,
                        isEast:  deltaLon(dest.lon, here.lon) > 0
                    };
                })
                .sort((a, b) => a.cost - b.cost);  // cheapest ‚Üí priciest

            const affordable   = all.filter(x => x.canAfford);
            const unaffordable = all.filter(x => !x.canAfford);

            /* -----------------------------------------
            * 2) Core selection logic (your old scheme)
            * ----------------------------------------- */
            const chosen = [];
            const addUnique = (obj) => {
                if (obj && !chosen.some(c => c.key === obj.key)) chosen.push(obj);
            };

            if (affordable.length >= 3) {
                addUnique(affordable[0]);                               // super-cheap
                addUnique(affordable[Math.floor(affordable.length/2)]); // mid-price
                addUnique(affordable[affordable.length-1]);             // top affordable
            } else {
                affordable.forEach(addUnique);
            }

            // fill up to 4 with random affordable picks
            const pool = affordable.filter(x => !chosen.includes(x));
            while (chosen.length < 4 && pool.length) {
                addUnique(pool.splice(Math.floor(Math.random()*pool.length), 1)[0]);
            }

            // still short? pad with cheapest unaffordable
            let uaIdx = 0;
            while (chosen.length < 4 && uaIdx < unaffordable.length) {
                addUnique(unaffordable[uaIdx++]);
            }

            /* -----------------------------------------
            * 3) Directional guarantee üëàüëâ
            * ----------------------------------------- */
            const ensureDirection = (wantWest) => {
                const hasDir = chosen.some(x => wantWest ? x.isWest : x.isEast);
                if (hasDir) return;  // nothing to do

                // candidate pool: try affordable first, else any
                const dirPool = (wantWest
                    ? affordable.filter(x => x.isWest)
                    : affordable.filter(x => x.isEast))
                    .concat( wantWest
                        ? all.filter(x => x.isWest && !x.canAfford)
                        : all.filter(x => x.isEast && !x.canAfford) );

                if (!dirPool.length) return;  // no such cities on the planet? Unlikely.

                const replacement = dirPool[0];               // cheapest of that direction
                // kick out the priciest already-chosen ticket to stay at 4 options
                chosen.sort((a,b) => b.cost - a.cost);
                chosen[0] = replacement;
            };

            ensureDirection(true);   // make sure we have ‚â•1 WEST
            ensureDirection(false);  // make sure we have ‚â•1 EAST

            /* -----------------------------------------
            * 4) Shuffle final four so UI doesn‚Äôt look rigged
            * ----------------------------------------- */
            for (let i = chosen.length-1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i+1));
                [chosen[i], chosen[j]] = [chosen[j], chosen[i]];
            }

            /* -----------------------------------------
            * 5) Render tickets & preview curves (unchanged)
            * ----------------------------------------- */
            previewCurves.forEach(c => scene.remove(c));
            previewCurves = [];

            chosen.forEach(({ key, destination, distance, transport, cost, canAfford, visited }) => {
                const curve = drawPreviewCurve(
                    here, destination,
                    canAfford ? 0x4ade80 : 0xff6b6b,
                    canAfford ? 0.5       : 0.2
                );
                previewCurves.push(curve);

                const el = document.createElement('div');
                el.className = `ticket ${visited ? 'visited' : ''} ${canAfford ? '' : 'disabled'}`;
                el.innerHTML = `
                    <div class="ticket-icon">${transport.icon}</div>
                    <div class="ticket-destination">${destination.name}</div>
                    <div style="font-size:0.9em;color:#94a3b8;">${transport.name}</div>
                    <div class="ticket-distance">${Math.round(distance)} km</div>
                    <div class="ticket-cost">$${cost}</div>
                    ${visited ? '<div class="visited-tag">‚≠ê Visited</div>' : ''}
                `;
                if (canAfford) {
                    el.onclick      = () => travel(key, distance, cost);
                    el.onmouseenter = () => { curve.material.opacity = 0.8; };
                    el.onmouseleave = () => { curve.material.opacity = 0.5; };
                }
                ticketsGrid.appendChild(el);
            });

            /* Header blurb */
            document.querySelector('#travelOptions h2').textContent =
                `Current location: ${here.name}. Choose your next move ‚Äì $${currentTeam.money} in the kitty.`;

            document.getElementById('travelOptions').classList.add('active');
        }



        // Draw preview curve
        function drawPreviewCurve(from, to, color, opacity) {
            const points = [];
            const segments = 30;

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const lat = from.lat + (to.lat - from.lat) * t;
                const lon = from.lon + (to.lon - from.lon) * t;
                
                // Add some height to make it a curve
                const height = 1.02 + Math.sin(t * Math.PI) * 0.1;
                const position = latLonToVector3(lat, lon, height);
                points.push(position);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 2,
                transparent: true,
                opacity: opacity
            });
            
            const curve = new THREE.Line(geometry, material);
            globe.add(curve);
            
            return curve;
        }

        // Travel to new location
        function travel(destinationKey, distance, cost) {
            const currentTeam = teams[currentTeamIndex];
            
            // Deduct money immediately
            currentTeam.money -= cost;
            
            // Store destination for after question
            pendingDestination = {
                key: destinationKey,
                distance: distance,
                cost: cost
            };
            
            // Clear preview curves
            previewCurves.forEach(curve => scene.remove(curve));
            previewCurves = [];
            
            document.getElementById('travelOptions').classList.remove('active');
            
            // Show question for the destination
            showQuestion();
        }

        // Next turn
        function nextTurn() {
            currentTeamIndex++;
            if (currentTeamIndex >= teams.length) {
                currentTeamIndex = 0;
                currentTurn++;
                
                if (currentTurn > maxTurns) {
                    endGame();
                    return;
                }
            }
            
            updateUI();
            updateTeamLabels();
            
            // Focus on current team's location
            const currentTeam = teams[currentTeamIndex];
            focusGlobeOnLocation(locations[currentTeam.currentLocation]);
            
            setTimeout(() => showTravelOptions(), 2000);
        }

        // Calculate distance between two points on Earth
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Convert lat/lon to 3D coordinates
        function latLonToVector3(lat, lon, radius = 1) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }

        // Add location marker
        function addLocationMarker(lat, lon, color = 0xff0000) {
            const position = latLonToVector3(lat, lon, 1.02);
            
            const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(position);
            
            // Add marker as child of globe so it rotates with it
            globe.add(marker);
            markers.push(marker);
            
            // Add pulsing effect
            marker.userData.pulse = 0;
            
            return marker;
        }

        // Draw travel line between locations
        function drawTravelLine(from, to, color = 0x00ff00) {
            const points = [];
            const segments = 50;

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const lat = from.lat + (to.lat - from.lat) * t;
                const lon = from.lon + (to.lon - from.lon) * t;
                
                // Add height to create an arc
                const height = 1.02 + Math.sin(t * Math.PI) * 0.15;
                const position = latLonToVector3(lat, lon, height);
                points.push(position);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            
            const travelLine = new THREE.Line(geometry, material);
            globe.add(travelLine);
            travelLines.push(travelLine);
        }

		// === Ny exakt centrerings-funktion ===
		function focusGlobeOnLocation(location, duration = 1500) {
			isAnimatingRotation = true;

			// 1. Vektor till mÔøΩlpunkten i globens lokalÔøΩkoordinater
			const localTarget = latLonToVector3(location.lat, location.lon, 1).normalize();

			// 2. Samma punkt i vÔøΩrldÔøΩkoordinater (med nuvarande orientering)
			const worldTarget = localTarget.clone().applyQuaternion(globe.quaternion).normalize();

			// 3. Vektorn frÔøΩn globens centrum mot kameran
			const cameraDir = camera.position.clone().normalize(); // (0,0,1) i ditt fall

			// 4. Quaternion som roterar worldTarget ? cameraDir
			const qRot = new THREE.Quaternion().setFromUnitVectors(worldTarget, cameraDir);

			// 5. Tweena snyggt mellan start- och slutÔøΩorientering
			const startQuat = globe.quaternion.clone();
			const endQuat   = qRot.multiply(startQuat);

			const startTime = performance.now();
			(function animateRotation(now) {
				const t = Math.min((now - startTime) / duration, 1);
				THREE.Quaternion.slerp(startQuat, endQuat, globe.quaternion, t);
				if (t < 1) {
					requestAnimationFrame(animateRotation);
				} else {
					isAnimatingRotation = false;
				}
			})(startTime);
		}


        // End game
        function endGame() {
            const finalScores = document.getElementById('finalScores');
            finalScores.innerHTML = '';
            
            // Sort teams by distance
            const sortedTeams = [...teams].sort((a, b) => b.totalDistance - a.totalDistance);
            
            sortedTeams.forEach((team, index) => {
                const isWinner = index === 0;
                finalScores.innerHTML += `
                    <div class="score-item ${isWinner ? 'winner' : ''}">
                        <div>
                            <div style="font-size: 1.2em; font-weight: bold;">${team.name}</div>
                            <div style="color: #94a3b8; font-size: 0.9em;">Money: $${team.money}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.3em; color: #fbbf24;">${Math.round(team.totalDistance)} km</div>
                            <div style="color: #94a3b8; font-size: 0.9em;">${team.locations.length} locations</div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('gameOverScreen').classList.add('active');
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            
            // Animate markers
            markers.forEach(marker => {
                marker.userData.pulse += 0.05;
                const scale = 1 + Math.sin(marker.userData.pulse) * 0.2;
                marker.scale.set(scale, scale, scale);
            });
            
            // Update sprite rotations to face camera
            [...cityLabels, ...teamLabels].forEach(sprite => {
                if (sprite) {
                    sprite.quaternion.copy(camera.quaternion);
                }
            });
            
            renderer.render(scene, camera);
        }

        // Initialize game
        initThreeJS();
        animate();
    </script>
</body>
</html>